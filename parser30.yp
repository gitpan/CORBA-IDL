/*
 *	Interface Definition Language (OMG IDL CORBA v3.0)
 */

%token	IDENTIFIER
%token	INTEGER_LITERAL
%token	STRING_LITERAL
%token	WIDE_STRING_LITERAL
%token	CHARACTER_LITERAL
%token	WIDE_CHARACTER_LITERAL
%token	FIXED_PT_LITERAL
%token	FLOATING_PT_LITERAL
	/*	Keyword		*/
%token	ABSTRACT
%token	ANY
%token	ATTRIBUTE
%token	BOOLEAN
%token	CASE
%token	CHAR
%token	COMPONENT
%token	CONST
%token	CONSUMES
%token	CONTEXT
%token	CUSTOM
%token	DEFAULT
%token	DOUBLE
%token	EMITS
%token	ENUM
%token	EVENTTYPE
%token	EXCEPTION
%token	FACTORY
%token	FALSE
%token	FINDER
%token	FIXED
%token	FLOAT
%token	GETRAISES
%token	HOME
%token	IMPORT
%token	IN
%token	INOUT
%token	INTERFACE
%token	LOCAL
%token	LONG
%token	MODULE
%token	MULTIPLE
%token	NATIVE
%token	OBJECT
%token	OCTET
%token	ONEWAY
%token	OUT
%token	PRIMARYKEY
%token	PRIVATE
%token	PROVIDES
%token	PUBLIC
%token	PUBLISHES
%token	RAISES
%token	READONLY
%token	SEQUENCE
%token	SETRAISES
%token	SHORT
%token	STRING
%token	STRUCT
%token	SUPPORTS
%token	SWITCH
%token	TRUE
%token	TRUNCATABLE
%token	TYPEDEF
%token	TYPEID
%token	TYPEPREFIX
%token	UNION
%token	USES
%token	UNSIGNED
%token	VALUEBASE
%token	VALUETYPE
%token	VOID
%token	WCHAR
%token	WSTRING

%start	specification

%%

/* 1 */		/* 3.5	OMG IDL Specification */
specification
:	imports		definitions
		{
			$_[0]->YYData->{root} = new Specification($_[0],
					'list_import'		=>	$_[1],
					'list_decl'			=>	$_[2],
			);
		}
|	definitions
		{
			$_[0]->YYData->{root} = new Specification($_[0],
					'list_decl'			=>	$_[1],
			);
		}
|	/* empty */
		{
			$_[0]->Error("Empty specification.\n");
		}
|	error
		{
			$_[0]->Error("definition declaration expected.\n");
		}
;

imports
:	import
		{
			[$_[1]];
		}
|	import		imports
		{
			unshift(@{$_[2]},$_[1]);
			$_[2];
		}
;

definitions
:	definition
		{
			[$_[1]->getRef()];
		}
|	definition	definitions
		{
			unshift(@{$_[2]},$_[1]->getRef());
			$_[2];
		}
;

/* 2 */
definition
:	type_dcl		';'
										#default action
|	const_dcl		';'
										#default action
|	except_dcl		';'
										#default action
|	interface		';'
										#default action
|	module			';'
										#default action
|	value			';'
										#default action
|	type_id_dcl		';'
										#default action
|	type_prefix_dcl	';'
										#default action
|	event			';'
										#default action
|	component		';'
										#default action
|	home_dcl		';'
										#default action
|	type_dcl		error
		{
			$_[0]->Warning("';' expected.\n");
			$_[0]->YYErrok();
			$_[1];						#default action
		}
|	const_dcl		error
		{
			$_[0]->Warning("';' expected.\n");
			$_[0]->YYErrok();
			$_[1];						#default action
		}
|	except_dcl		error
		{
			$_[0]->Warning("';' expected.\n");
			$_[0]->YYErrok();
			$_[1];						#default action
		}
|	interface		error
		{
			$_[0]->Warning("';' expected.\n");
			$_[0]->YYErrok();
			$_[1];						#default action
		}
|	module			error
		{
			$_[0]->Warning("';' expected.\n");
			$_[0]->YYErrok();
			$_[1];						#default action
		}
|	value			error
		{
			$_[0]->Warning("';' expected.\n");
			$_[0]->YYErrok();
			$_[1];						#default action
		}
|	type_id_dcl		error
		{
			$_[0]->Warning("';' expected.\n");
			$_[0]->YYErrok();
			$_[1];						#default action
		}
|	type_prefix_dcl	error
		{
			$_[0]->Warning("';' expected.\n");
			$_[0]->YYErrok();
			$_[1];						#default action
		}
|	event			error
		{
			$_[0]->Warning("';' expected.\n");
			$_[0]->YYErrok();
			$_[1];						#default action
		}
|	component		error
		{
			$_[0]->Warning("';' expected.\n");
			$_[0]->YYErrok();
			$_[1];						#default action
		}
|	home_dcl		error
		{
			$_[0]->Warning("';' expected.\n");
			$_[0]->YYErrok();
			$_[1];						#default action
		}
;

/* 3 */		/* 3.7	Module Declaration */
module
:	module_header	'{'	definitions	'}'
		{
			$_[0]->YYData->{symbtab}->PopCurrentRoot($_[1]);
			$_[1]->Configure($_[0],
					'list_decl'			=>	$_[3]
			) if (defined $_[1]);
		}
|	module_header	'{'	error		'}'
		{
			$_[0]->YYData->{symbtab}->PopCurrentRoot($_[1]);
			$_[0]->Error("definition declaration expected.\n");
			$_[0]->YYErrok();
		}
|	module_header	'{'	'}'
		{
			$_[0]->YYData->{symbtab}->PopCurrentRoot($_[1]);
			$_[0]->Error("Empty module.\n");
			$_[0]->YYErrok();
		}
|	module_header	error	'}'
		{
			$_[0]->YYData->{symbtab}->PopCurrentRoot($_[1]);
			$_[0]->Error("'\x7b' expected.\n");
			$_[0]->YYErrok();
		}
;

module_header
:	MODULE	IDENTIFIER
		{
			new Module($_[0],
					'idf'				=>	$_[2],
			);
		}
|	MODULE	error
		{
			$_[0]->Error("Identifier expected.\n");
			$_[0]->YYErrok();
		}
;

/* 4 */		/* 3.8	Interface Declaration */
interface
:	interface_dcl
										#default action
|	forward_dcl
										#default action
;

/* 5 */
interface_dcl
:	interface_header	'{'	'}'
		{
			$_[0]->YYData->{symbtab}->PopCurrentScope($_[1]);
			$_[0]->YYData->{curr_itf} = undef;
			$_[1]->Configure($_[0],
					'list_decl'		=>	[]
			) if (defined $_[1]);
		}
|	interface_header	'{'	interface_body	'}'
		{
			$_[0]->YYData->{symbtab}->PopCurrentScope($_[1]);
			$_[0]->YYData->{curr_itf} = undef;
			$_[1]->Configure($_[0],
					'list_decl'		=>	$_[3]
			) if (defined $_[1]);
		}
|	interface_header	'{'	error			'}'
		{
			$_[0]->YYData->{symbtab}->PopCurrentScope($_[1]);
			$_[0]->YYData->{curr_itf} = undef;
			$_[0]->Error("export declaration expected.\n");
			$_[0]->YYErrok();
		}
;

/* 6 */		/* 3.8.4	Forward Declaration */
forward_dcl
:	interface_mod	INTERFACE	IDENTIFIER
		{
			if (defined $_[1] and $_[1] eq 'abstract') {
				new ForwardAbstractInterface($_[0],
						'idf'					=>	$_[3]
				);
			} elsif (defined $_[1] and $_[1] eq 'local') {
				new ForwardLocalInterface($_[0],
						'idf'					=>	$_[3]
				);
			} else {
				new ForwardRegularInterface($_[0],
						'idf'					=>	$_[3]
				);
			}
		}
|	interface_mod	INTERFACE	error
		{
			$_[0]->Error("Identifier expected.\n");
			$_[0]->YYErrok();
		}
;

interface_mod
:	ABSTRACT		/* 3.8.6	Abstract Interface */
										#default action
|	LOCAL			/* 3.8.7	Local Interface */
										#default action
|	/* empty */
										#default action
;

/* 7 */		/* 3.8.1	Interface Header */
interface_header
:	interface_mod	INTERFACE	IDENTIFIER
		{
			if (defined $_[1] and $_[1] eq 'abstract') {
				new AbstractInterface($_[0],
						'idf'					=>	$_[3]
				);
			} elsif (defined $_[1] and $_[1] eq 'local') {
				new LocalInterface($_[0],
						'idf'					=>	$_[3]
				);
			} else {
				new RegularInterface($_[0],
						'idf'					=>	$_[3]
				);
			}
		}
|	interface_mod	INTERFACE	IDENTIFIER	interface_inheritance_spec
		{
			my $inheritance = new InheritanceSpec($_[0],
					'list_interface'		=>	$_[4]
			);
			if (defined $_[1] and $_[1] eq 'abstract') {
				new AbstractInterface($_[0],
						'idf'					=>	$_[3],
						'inheritance'			=>	$inheritance
				);
			} elsif (defined $_[1] and $_[1] eq 'local') {
				new LocalInterface($_[0],
						'idf'					=>	$_[3],
						'inheritance'			=>	$inheritance
				);
			} else {
				new RegularInterface($_[0],
						'idf'					=>	$_[3],
						'inheritance'			=>	$inheritance
				);
			}
		}
|	interface_mod	INTERFACE	error
		{
			$_[0]->Error("Identifier expected.\n");
			$_[0]->YYErrok();
		}
;

/* 8 */		/* 3.8.3	Interface Body */
interface_body
:	exports
										#default action
;

exports
:	export
		{
			[$_[1]->getRef()];
		}
|	export	exports
		{
			unshift(@{$_[2]},$_[1]->getRef());
			$_[2];
		}
;

/* 9 */
export
:	type_dcl		';'
										#default action
|	const_dcl		';'
										#default action
|	except_dcl		';'
										#default action
|	attr_dcl		';'
										#default action
|	op_dcl			';'
										#default action
|	type_id_dcl		';'
										#default action
|	type_prefix_dcl	';'
										#default action
|	type_dcl		error
		{
			$_[0]->Warning("';' expected.\n");
			$_[0]->YYErrok();
			$_[1];						#default action
		}
|	const_dcl		error
		{
			$_[0]->Warning("';' expected.\n");
			$_[0]->YYErrok();
			$_[1];						#default action
		}
|	except_dcl		error
		{
			$_[0]->Warning("';' expected.\n");
			$_[0]->YYErrok();
			$_[1];						#default action
		}
|	attr_dcl		error
		{
			$_[0]->Warning("';' expected.\n");
			$_[0]->YYErrok();
			$_[1];						#default action
		}
|	op_dcl			error
		{
			$_[0]->Warning("';' expected.\n");
			$_[0]->YYErrok();
			$_[1];						#default action
		}
|	type_id_dcl		error
		{
			$_[0]->Warning("';' expected.\n");
			$_[0]->YYErrok();
			$_[1];						#default action
		}
|	type_prefix_dcl	error
		{
			$_[0]->Warning("';' expected.\n");
			$_[0]->YYErrok();
			$_[1];						#default action
		}
;

/* 10 */	/* 3.8.5	Interface Inheritance */
interface_inheritance_spec
:	':'	interface_names
		{
			$_[2];
		}
|	':'	error
		{
			$_[0]->Error("Interface name expected.\n");
			$_[0]->YYErrok();
		}
;

interface_names
:	interface_name
		{
			[$_[1]];
		}
|	interface_name	','	interface_names
		{
			unshift(@{$_[3]},$_[1]);
			$_[3];
		}
;

/* 11 */
interface_name
:	scoped_name
		{
				Interface->Lookup($_[0],$_[1]);
		}
;

/* 12 */
scoped_name
:	IDENTIFIER
										#default action
|	'::'	IDENTIFIER
		{
			$_[1] . $_[2];
		}
|	'::'	error
		{
			$_[0]->Error("Identifier expected.\n");
			$_[0]->YYErrok();
			'';
		}
|	scoped_name	'::'	IDENTIFIER
		{
			$_[1] . $_[2] . $_[3];
		}
|	scoped_name	'::'	error
		{
			$_[0]->Error("Identifier expected.\n");
			$_[0]->YYErrok();
			$_[1];
		}
;

/* 13 */	/* 3.9	Value Declaration */
value
:	value_dcl
										#default action
|	value_abs_dcl
										#default action
|	value_box_dcl
										#default action
|	value_forward_dcl
										#default action
;

/* 14 */	/* 3.9.4	Value Forward declaration */
value_forward_dcl
:				VALUETYPE	IDENTIFIER
		{
			new ForwardRegularValue($_[0],
					'idf'				=>	$_[2]
			);
		}
|	ABSTRACT	VALUETYPE	IDENTIFIER
		{
			new ForwardAbstractValue($_[0],
					'idf'				=>	$_[3]
			);
		}
;

/* 15 */	/*	3.9.2	Boxed Value Type */
value_box_dcl
:	VALUETYPE	IDENTIFIER	type_spec
		{
			new BoxedValue($_[0],
					'idf'				=>	$_[2],
					'type'				=>	$_[3]
			);
		}
;

/* 16 */	/* 3.9.3	Abstract Value Type */
value_abs_dcl
:	value_abs_header	'{'	'}'
		{
			$_[0]->YYData->{symbtab}->PopCurrentScope($_[1]);
			$_[0]->YYData->{curr_itf} = undef;
			$_[1]->Configure($_[0],
					'list_decl'		=>	[]
			) if (defined $_[1]);
		}
|	value_abs_header	'{'	exports	'}'
		{
			$_[0]->YYData->{symbtab}->PopCurrentScope($_[1]);
			$_[0]->YYData->{curr_itf} = undef;
			$_[1]->Configure($_[0],
					'list_decl'		=>	$_[3]
			) if (defined $_[1]);
		}
|	value_abs_header	'{'	error	'}'
		{
			$_[0]->YYData->{symbtab}->PopCurrentScope($_[1]);
			$_[0]->YYData->{curr_itf} = undef;
			$_[0]->Error("export declaration expected.\n");
			$_[0]->YYErrok();
		}
;

value_abs_header
:	ABSTRACT	VALUETYPE	IDENTIFIER
		{
			new AbstractValue($_[0],
					'idf'				=>	$_[3]
			);
		}
|	ABSTRACT	VALUETYPE	IDENTIFIER	value_inheritance_spec
		{
			new AbstractValue($_[0],
					'idf'				=>	$_[3],
					'inheritance'		=>	$_[4]
			);
		}
|	ABSTRACT	VALUETYPE	error
		{
			$_[0]->Error("Identifier expected.\n");
			$_[0]->YYErrok();
		}
|	ABSTRACT	error
		{
			$_[0]->Error("'valuetype' expected.\n");
			$_[0]->YYErrok();
		}
;

/* 17 */	/* 3.9.1	Regular Value Type */
value_dcl
:	value_header	'{'	'}'
		{
			$_[0]->YYData->{symbtab}->PopCurrentScope($_[1]);
			$_[0]->YYData->{curr_itf} = undef;
			$_[1]->Configure($_[0],
					'list_decl'		=>	[]
			) if (defined $_[1]);
		}
|	value_header	'{'	value_elements	'}'
		{
			$_[0]->YYData->{symbtab}->PopCurrentScope($_[1]);
			$_[0]->YYData->{curr_itf} = undef;
			$_[1]->Configure($_[0],
					'list_decl'		=>	$_[3]
			) if (defined $_[1]);
		}
|	value_header	'{'	error			'}'
		{
			$_[0]->YYData->{symbtab}->PopCurrentScope($_[1]);
			$_[0]->YYData->{curr_itf} = undef;
			$_[0]->Error("value_element expected.\n");
			$_[0]->YYErrok();
		}
;

value_elements
:	value_element
		{
			[$_[1]->getRef()];
		}
|	value_element	value_elements
		{
			unshift(@{$_[2]},$_[1]->getRef());
			$_[2];
		}
;

/* 18 */
value_header
:				VALUETYPE	IDENTIFIER
		{
			new RegularValue($_[0],
					'idf'				=>	$_[2]
			);
		}
|	CUSTOM		VALUETYPE	IDENTIFIER
		{
			new RegularValue($_[0],
					'modifier'			=>	$_[1],
					'idf'				=>	$_[3]
			);
		}
|				VALUETYPE	IDENTIFIER	value_inheritance_spec
		{
			new RegularValue($_[0],
					'idf'				=>	$_[2],
					'inheritance'		=>	$_[3]
			);
		}
|	CUSTOM		VALUETYPE	IDENTIFIER	value_inheritance_spec
		{
			new RegularValue($_[0],
					'modifier'			=>	$_[1],
					'idf'				=>	$_[3],
					'inheritance'		=>	$_[4]
			);
		}
|				VALUETYPE	error
		{
			$_[0]->Error("Identifier expected.\n");
			$_[0]->YYErrok();
		}
|	CUSTOM		VALUETYPE	error
		{
			$_[0]->Error("Identifier expected.\n");
			$_[0]->YYErrok();
		}
|	CUSTOM		error
		{
			$_[0]->Error("valuetype expected.\n");
			$_[0]->YYErrok();
		}
;

/* 19 */	/* 3.9.5	Valuetype Inheritance */
value_inheritance_spec
:	':'	inheritance_mod	value_names
		{
			new InheritanceSpec($_[0],
					'modifier'			=>	$_[2],
					'list_value'		=>	$_[3]
			);
		}
|	':'	inheritance_mod	value_names	supported_interface_spec
		{
			new InheritanceSpec($_[0],
					'modifier'			=>	$_[2],
					'list_value'		=>	$_[3],
					'list_interface'	=>	$_[4]
			);
		}
|	':'	inheritance_mod	error
		{
			$_[0]->Error("value_name expected.\n");
			$_[0]->YYErrok();
		}
|									supported_interface_spec
		{
			new InheritanceSpec($_[0],
					'list_interface'	=>	$_[1]
			);
		}
;

inheritance_mod
:	TRUNCATABLE
										#default action
|	/* empty */
										#default action
;

value_names
:	value_name
		{
			[$_[1]];
		}
|	value_name	','	value_names
		{
			unshift(@{$_[3]},$_[1]);
			$_[3];
		}
;

/* 20 */
value_name
:	scoped_name
		{
			Value->Lookup($_[0],$_[1]);
		}
;

/* 21 */
value_element
:	export
										#default action
|	state_member
										#default action
|	init_dcl
										#default action
;

/* 22 */	/* 3.9.1.4	State Members */
state_member
:	state_mod	type_spec	declarators	';'
		{
			new StateMembers($_[0],
					'modifier'			=>	$_[1],
					'type'				=>	$_[2],
					'list_expr'			=>	$_[3]
			);
		}
|	state_mod	error	';'
		{
			$_[0]->Error("type_spec expected.\n");
			$_[0]->YYErrok();
		}
;

state_mod
:	PUBLIC
										#default action
|	PRIVATE
										#default action
;

/* 23 */	/* 3.9.1.5	Initializers */
init_dcl
:	init_header_param	raises_expr	';'
		{
			$_[1]->Configure($_[0],
					'list_raise'	=>	$_[2]
			) if (defined $_[1]);
		}
|	init_header_param	raises_expr	error
		{
			$_[0]->Warning("';' expected.\n");
			$_[0]->YYErrok();
			$_[1]->Configure($_[0],
					'list_raise'	=>	$_[2]
			) if (defined $_[1]);
		}
|	init_header_param	';'
										#default action
|	init_header_param	error
		{
			$_[0]->Warning("';' expected.\n");
			$_[0]->YYErrok();
			$_[1];						#default action
		}
;

init_header_param
:	init_header	'('	')'
		{
			delete $_[0]->YYData->{unnamed_symbtab}
					if (exists $_[0]->YYData->{unnamed_symbtab});
			$_[1];						#default action
		}
|	init_header	'('	init_param_decls	')'
		{
			delete $_[0]->YYData->{unnamed_symbtab}
					if (exists $_[0]->YYData->{unnamed_symbtab});
			$_[1]->Configure($_[0],
					'list_param'	=>	$_[3]
			) if (defined $_[1]);
		}
|	init_header	'('	error				')'
		{
			delete $_[0]->YYData->{unnamed_symbtab}
					if (exists $_[0]->YYData->{unnamed_symbtab});
			$_[0]->Error("init_param_decls expected.\n");
			$_[0]->YYErrok();
		}
|	init_header	error
		{
			delete $_[0]->YYData->{unnamed_symbtab}
					if (exists $_[0]->YYData->{unnamed_symbtab});
			$_[0]->Error("'(' expected.\n");
			$_[0]->YYErrok();
		}
;

init_header
:	FACTORY	IDENTIFIER
		{
			new Initializer($_[0],						# like Operation
					'idf'				=>	$_[2]
			);
		}
|	FACTORY	error
		{
			$_[0]->Error("Identifier expected.\n");
			$_[0]->YYErrok();
		}
;

/* 24 */
init_param_decls
:	init_param_decl
		{
			[$_[1]];
		}
|	init_param_decl	','	init_param_decls
		{
			unshift(@{$_[3]},$_[1]);
			$_[3];
		}
;

/* 25 */
init_param_decl
:	init_param_attribute	param_type_spec		simple_declarator
		{
			new Parameter($_[0],
					'attr'				=>	$_[1],
					'type'				=>	$_[2],
					'idf'				=>	$_[3]
			);
		}
|	init_param_attribute	error
		{
			$_[0]->Error("Type expected.\n");
			$_[0]->YYErrok();
		}
;

/* 26 */
init_param_attribute
:	IN
										#default action
;

/* 27 */	/* 3.10	Constant Declaration */
const_dcl
:	CONST	const_type	IDENTIFIER	'='	const_exp
		{
			new Constant($_[0],
					'type'				=>	$_[2],
					'idf'				=>	$_[3],
					'list_expr'			=>	$_[5]
			);
		}
|	CONST	const_type	IDENTIFIER	'='	error
		{
			$_[0]->Error("Expression expected.\n");
			$_[0]->YYErrok();
		}
|	CONST	const_type	IDENTIFIER	error
		{
			$_[0]->Error("'=' expected.\n");
			$_[0]->YYErrok();
		}
|	CONST	const_type	error
		{
			$_[0]->Error("Identifier expected.\n");
			$_[0]->YYErrok();
		}
|	CONST	error
		{
			$_[0]->Error("const_type expected.\n");
			$_[0]->YYErrok();
		}
;

/* 28 */
const_type
:	integer_type
										#default action
|	char_type
										#default action
|	wide_char_type
										#default action
|	boolean_type
										#default action
|	floating_pt_type
										#default action
|	string_type
										#default action
|	wide_string_type
										#default action
|	fixed_pt_const_type
										#default action
|	scoped_name
		{
			TypeDeclarator->Lookup($_[0],$_[1]);
		}
|	octet_type
										#default action
;

/* 29 */
const_exp
:	or_expr
										#default action
;

/* 30 */
or_expr
:	xor_expr
										#default action
|	or_expr		'|'		xor_expr
		{
			BuildBinop($_[1],$_[2],$_[3]);
		}
;

/* 31 */
xor_expr
:	and_expr
										#default action
|	xor_expr	'^'		and_expr
		{
			BuildBinop($_[1],$_[2],$_[3]);
		}
;

/* 32 */
and_expr
:	shift_expr
										#default action
|	and_expr	'&'		shift_expr
		{
			BuildBinop($_[1],$_[2],$_[3]);
		}
;

/* 33 */
shift_expr
:	add_expr
										#default action
|	shift_expr	'>>'	add_expr
		{
			BuildBinop($_[1],$_[2],$_[3]);
		}
|	shift_expr	'<<'	add_expr
		{
			BuildBinop($_[1],$_[2],$_[3]);
		}
;

/* 34 */
add_expr
:	mult_expr
										#default action
|	add_expr	'+'		mult_expr
		{
			BuildBinop($_[1],$_[2],$_[3]);
		}
|	add_expr	'-'		mult_expr
		{
			BuildBinop($_[1],$_[2],$_[3]);
		}
;

/* 35 */
mult_expr
:	unary_expr
										#default action
|	mult_expr	'*'		unary_expr
		{
			BuildBinop($_[1],$_[2],$_[3]);
		}
|	mult_expr	'/'		unary_expr
		{
			BuildBinop($_[1],$_[2],$_[3]);
		}
|	mult_expr	'%'		unary_expr
		{
			BuildBinop($_[1],$_[2],$_[3]);
		}
;

/* 36 */
unary_expr
:	unary_operator	primary_expr
		{
			BuildUnop($_[1],$_[2]);
		}
|	primary_expr
										#default action
;

/* 37 */
unary_operator
:	'-'
										#default action
|	'+'
										#default action
|	'~'
										#default action
;

/* 38 */
primary_expr
:	scoped_name
		{
			[
				Constant->Lookup($_[0],$_[1])
			];
		}
|	literal
		{
			[ $_[1] ];
		}
|	'('	const_exp	')'
		{
			$_[2];
		}
|	'('	error		')'
		{
			$_[0]->Error("Expression expected.\n");
			$_[0]->YYErrok();
		}
;

/* 39 */
literal
:	INTEGER_LITERAL
		{
			new IntegerLiteral($_[0],
					'value'				=>	$_[1],
					'lexeme'			=>	$_[0]->YYData->{lexeme}
			);
		}
|	string_literal
		{
			new StringLiteral($_[0],
					'value'				=>	$_[1]
			);
		}
|	wide_string_literal
		{
			new WideStringLiteral($_[0],
					'value'				=>	$_[1]
			);
		}
|	CHARACTER_LITERAL
		{
			new CharacterLiteral($_[0],
					'value'				=>	$_[1]
			);
		}
|	WIDE_CHARACTER_LITERAL
		{
			new WideCharacterLiteral($_[0],
					'value'				=>	$_[1]
			);
		}
|	FIXED_PT_LITERAL
		{
			new FixedPtLiteral($_[0],
					'value'				=>	$_[1],
					'lexeme'			=>	$_[0]->YYData->{lexeme}
			);
		}
|	FLOATING_PT_LITERAL
		{
			new FloatingPtLiteral($_[0],
					'value'				=>	$_[1],
					'lexeme'			=>	$_[0]->YYData->{lexeme}
			);
		}
|	boolean_literal
										#default action
;

string_literal
:	STRING_LITERAL
										#default action
|	STRING_LITERAL	string_literal
		{
			$_[1] . $_[2];
		}
;

wide_string_literal
:	WIDE_STRING_LITERAL
										#default action
|	WIDE_STRING_LITERAL	wide_string_literal
		{
			$_[1] . $_[2];
		}
;

/* 40 */
boolean_literal
:	TRUE
		{
			new BooleanLiteral($_[0],
					'value'				=>	1
			);
		}
|	FALSE
		{
			new BooleanLiteral($_[0],
					'value'				=>	0
			);
		}
;

/* 41 */
positive_int_const
:	const_exp
		{
			new Expression($_[0],
					'list_expr'			=>	$_[1]
			);
		}
;

/* 42 */	/* 3.11		Type Declaration */
type_dcl
:	TYPEDEF		type_declarator
		{
			$_[2];
		}
|	struct_type
										#default action
|	union_type
										#default action
|	enum_type
										#default action
|	NATIVE		simple_declarator		/* 3.11.5	Native Types */
		{
			new TypeDeclarator($_[0],
					'modifier'			=>	$_[1],
					'idf'				=>	$_[2]
			);
		}
|	constr_forward_decl
										#default action
|	TYPEDEF		error
		{
			$_[0]->Error("type_declarator expected.\n");
			$_[0]->YYErrok();
		}
;

/* 43 */
type_declarator
:	type_spec	declarators
		{
			new TypeDeclarators($_[0],
					'type'				=>	$_[1],
					'list_expr'			=>	$_[2]
			);
		}
;

/* 44 */
type_spec
:	simple_type_spec
										#default action
|	constr_type_spec
										#default action
;

/* 45 */
simple_type_spec
:	base_type_spec
										#default action
|	template_type_spec
										#default action
|	scoped_name
		{
			TypeDeclarator->Lookup($_[0],$_[1]);
		}
;

/* 46 */
base_type_spec
:	floating_pt_type
										#default action
|	integer_type
										#default action
|	char_type
										#default action
|	wide_char_type
										#default action
|	boolean_type
										#default action
|	octet_type
										#default action
|	any_type
										#default action
|	object_type
										#default action
|	value_base_type
										#default action
;

/* 47 */	/* 3.11.3	Template Types */
template_type_spec
:	sequence_type
										#default action
|	string_type
										#default action
|	wide_string_type
										#default action
|	fixed_pt_type
										#default action
;

/* 48 */	/* 3.11.2	Constructed Types */
constr_type_spec
:	struct_type
										#default action
|	union_type
										#default action
|	enum_type
										#default action
;

/* 49 */
declarators
:	declarator
		{
			[$_[1]];
		}
|	declarator	','	declarators
		{
			unshift(@{$_[3]},$_[1]);
			$_[3];
		}
;

/* 50 */
declarator
:	simple_declarator
		{
			[$_[1]];
		}
|	complex_declarator
										#default action
;

/* 51 */
simple_declarator
:	IDENTIFIER
										#default action
|	error	','
		{
			$_[0]->Error("Identifier expected.\n");
			$_[0]->YYErrok();
		}
|	error	';'
		{
			$_[0]->Error("Identifier expected.\n");
			$_[0]->YYErrok();
		}
;

/* 52 */
complex_declarator
:	array_declarator
										#default action
;

/* 53 */	/* 3.11.1	Basic Types */
floating_pt_type
:	FLOAT
		{
			new FloatingPtType($_[0],
					'value'				=>	$_[1]
			);
		}
|	DOUBLE
		{
			new FloatingPtType($_[0],
					'value'				=>	$_[1]
			);
		}
|	LONG	DOUBLE
		{
			new FloatingPtType($_[0],
					'value'				=>	$_[1] . ' ' . $_[2]
			);
		}
;

/* 54 */
integer_type
:	signed_int
										#default action
|	unsigned_int
										#default action
;

/* 55 */
signed_int
:	signed_short_int
										#default action
|	signed_long_int
										#default action
|	signed_longlong_int
										#default action
;

/* 56 */
signed_short_int
:	SHORT
		{
			new IntegerType($_[0],
					'value'				=>	$_[1]
			);
		}
;

/* 57 */
signed_long_int
:	LONG
		{
			new IntegerType($_[0],
					'value'				=>	$_[1]
			);
		}
;

/* 58 */
signed_longlong_int
:	LONG	LONG
		{
			new IntegerType($_[0],
					'value'				=>	$_[1] . ' ' . $_[2]
			);
		}
;

/* 59 */
unsigned_int
:	unsigned_short_int
										#default action
|	unsigned_long_int
										#default action
|	unsigned_longlong_int
										#default action
;

/* 60 */
unsigned_short_int
:	UNSIGNED	SHORT
		{
			new IntegerType($_[0],
					'value'				=>	$_[1] . ' ' . $_[2]
			);
		}
;

/* 61 */
unsigned_long_int
:	UNSIGNED	LONG
		{
			new IntegerType($_[0],
					'value'				=>	$_[1] . ' ' . $_[2]
			);
		}
;

/* 62 */
unsigned_longlong_int
:	UNSIGNED	LONG	LONG
		{
			new IntegerType($_[0],
					'value'				=>	$_[1] . ' ' . $_[2] . ' ' . $_[3]
			);
		}
;

/* 63 */
char_type
:	CHAR
		{
			new CharType($_[0],
					'value'				=>	$_[1]
			);
		}
;

/* 64 */
wide_char_type
:	WCHAR
		{
			new WideCharType($_[0],
					'value'				=>	$_[1]
			);
		}
;

/* 65 */
boolean_type
:	BOOLEAN
		{
			new BooleanType($_[0],
					'value'				=>	$_[1]
			);
		}
;

/* 66 */
octet_type
:	OCTET
		{
			new OctetType($_[0],
					'value'				=>	$_[1]
			);
		}
;

/* 67 */
any_type
:	ANY
		{
			new AnyType($_[0],
					'value'				=>	$_[1]
			);
		}
;

/* 68 */
object_type
:	OBJECT
		{
			new ObjectType($_[0],
					'value'				=>	$_[1]
			);
		}
;

/* 69 */	/* 3.11.2.1	Structures */
struct_type
:	struct_header	'{'	member_list	'}'
		{
			$_[0]->YYData->{symbtab}->PopCurrentScope($_[1]);
			$_[1]->Configure($_[0],
					'list_expr'			=>	$_[3]
			) if (defined $_[1]);
		}
|	struct_header	'{'	error		'}'
		{
			$_[0]->YYData->{symbtab}->PopCurrentScope($_[1]);
			$_[0]->Error("member expected.\n");
			$_[0]->YYErrok();
		}
;

struct_header
:	STRUCT	IDENTIFIER
		{
			new StructType($_[0],
					'idf'				=>	$_[2]
			);
		}
|	STRUCT	error
		{
			$_[0]->Error("Identifier expected.\n");
			$_[0]->YYErrok();
		}
;

/* 70 */
member_list
:	member
		{
			[$_[1]];
		}
|	member	member_list
		{
			unshift(@{$_[2]},$_[1]);
			$_[2];
		}
;

/* 71 */
member
:	type_spec	declarators	';'
		{
			new Members($_[0],
					'type'				=>	$_[1],
					'list_expr'			=>	$_[2]
			);
		}
|	type_spec	declarators	error
		{
			$_[0]->Error("';' expected.\n");
			$_[0]->YYErrok();
			new Members($_[0],
					'type'				=>	$_[1],
					'list_expr'			=>	$_[2]
			);
		}
;

/* 72 */	/* 3.11.2.2	Discriminated Unions */
union_type
:	union_header	SWITCH	'('	switch_type_spec	')'	'{'	switch_body	'}'
		{
			$_[0]->YYData->{symbtab}->PopCurrentScope($_[1]);
			$_[1]->Configure($_[0],
					'type'				=>	$_[4],
					'list_expr'			=>	$_[7]
			) if (defined $_[1]);
		}
|	union_header	SWITCH	'('	switch_type_spec	')'	'{'	error		'}'
		{
			$_[0]->YYData->{symbtab}->PopCurrentScope($_[1]);
			$_[0]->Error("switch_body expected.\n");
			$_[0]->YYErrok();
		}
|	union_header	SWITCH	'('	switch_type_spec	')'	error
		{
			$_[0]->YYData->{symbtab}->PopCurrentScope($_[1]);
			$_[0]->Error("'\x7b' expected.\n");
			$_[0]->YYErrok();
		}
|	union_header	SWITCH	'('	error				')'
		{
			$_[0]->YYData->{symbtab}->PopCurrentScope($_[1]);
			$_[0]->Error("switch_type_spec expected.\n");
			$_[0]->YYErrok();
		}
|	union_header	SWITCH	error
		{
			$_[0]->YYData->{symbtab}->PopCurrentScope($_[1]);
			$_[0]->Error("'(' expected.\n");
			$_[0]->YYErrok();
		}
;

union_header
:	UNION	IDENTIFIER
		{
			new UnionType($_[0],
					'idf'				=>	$_[2],
			);
		}
|	UNION	error
		{
			$_[0]->Error("Identifier expected.\n");
			$_[0]->YYErrok();
		}
;

/* 73 */
switch_type_spec
:	integer_type
										#default action
|	char_type
										#default action
|	boolean_type
										#default action
|	enum_type
										#default action
|	scoped_name
		{
			TypeDeclarator->Lookup($_[0],$_[1]);
		}
;

/* 74 */
switch_body
:	case
		{
			[$_[1]];
		}
|	case	switch_body
		{
			unshift(@{$_[2]},$_[1]);
			$_[2];
		}
;

/* 75 */
case
:	case_labels	element_spec	';'
		{
			new Case($_[0],
					'list_label'		=>	$_[1],
					'element'			=>	$_[2]
			);
		}
|	case_labels	element_spec	error
		{
			$_[0]->Error("';' expected.\n");
			$_[0]->YYErrok();
			new Case($_[0],
					'list_label'		=>	$_[1],
					'element'			=>	$_[2]
			);
		}
;

case_labels
:	case_label
		{
			[$_[1]];
		}
|	case_label	case_labels
		{
			unshift(@{$_[2]},$_[1]);
			$_[2];
		}
;

/* 76 */
case_label
:	CASE	const_exp	':'
		{
			$_[2];						# here only a expression, type is not known
		}
|	CASE	const_exp	error
		{
			$_[0]->Error("':' expected.\n");
			$_[0]->YYErrok();
			$_[2];
		}
|	CASE	error
		{
			$_[0]->Error("Expression expected.\n");
			$_[0]->YYErrok();
		}
|	DEFAULT		':'
		{
			new Default($_[0]);
		}
|	DEFAULT		error
		{
			$_[0]->Error("':' expected.\n");
			$_[0]->YYErrok();
			new Default($_[0]);
		}
;

/* 77 */
element_spec
:	type_spec	declarator
		{
			new Element($_[0],
					'type'			=>	$_[1],
					'list_expr'		=>	$_[2]
			);
		}
;

/* 78 */	/* 3.11.2.4	Enumerations */
enum_type
:	enum_header	'{'	enumerators	'}'
		{
			$_[1]->Configure($_[0],
					'list_expr'		=>	$_[3]
			) if (defined $_[1]);
		}
|	enum_header	'{'	error		'}'
		{
			$_[0]->Error("enumerator expected.\n");
			$_[0]->YYErrok();
		}
|	enum_header	error
		{
			$_[0]->Error("'\x7b' expected.\n");
			$_[0]->YYErrok();
		}
;

enum_header
:	ENUM	IDENTIFIER
		{
			new EnumType($_[0],
					'idf'				=>	$_[2],
			);
		}
|	ENUM	error
		{
			$_[0]->Error("Identifier expected.\n");
			$_[0]->YYErrok();
		}
;

enumerators
:	enumerator
		{
			[$_[1]];
		}
|	enumerator	','	enumerators
		{
			unshift(@{$_[3]},$_[1]);
			$_[3];
		}
|	enumerator	','
		{
			$_[0]->Warning("',' unexpected.\n");
			[$_[1]];
		}
|	enumerator	';'
		{
			$_[0]->Error("';' unexpected.\n");
			[$_[1]];
		}
;

/* 79 */
enumerator
:	IDENTIFIER
		{
			new Enum($_[0],
					'idf'				=>	$_[1]
			);
		}
;

/* 80 */	/* 3.11.3.1	Sequences */
sequence_type
:	SEQUENCE	'<'	simple_type_spec	','	positive_int_const	'>'
		{
			new SequenceType($_[0],
					'value'				=>	$_[1],
					'type'				=>	$_[3],
					'max'				=>	$_[5]
			);
		}
|	SEQUENCE	'<'	simple_type_spec	','	error				'>'
		{
			$_[0]->Error("Expression expected.\n");
			$_[0]->YYErrok();
		}
|	SEQUENCE	'<'	simple_type_spec	'>'
		{
			new SequenceType($_[0],
					'value'				=>	$_[1],
					'type'				=>	$_[3]
			);
		}
|	SEQUENCE	'<'	error  				'>'
		{
			$_[0]->Error("simple_type_spec expected.\n");
			$_[0]->YYErrok();
		}
|	SEQUENCE	error
		{
			$_[0]->Error("'<' expected.\n");
			$_[0]->YYErrok();
		}
;

/* 81 */	/* 3.11.3.2	Strings */
string_type
:	STRING	'<'	positive_int_const	'>'
		{
			new StringType($_[0],
					'value'				=>	$_[1],
					'max'				=>	$_[3]
			);
		}
|	STRING
		{
			new StringType($_[0],
					'value'				=>	$_[1]
			);
		}
|	STRING	'<'	error				'>'
		{
			$_[0]->Error("Expression expected.\n");
			$_[0]->YYErrok();
		}
;

/* 82 */	/* 3.11.3.3	Wstrings */
wide_string_type
:	WSTRING	'<'	positive_int_const	'>'
		{
			new WideStringType($_[0],
					'value'				=>	$_[1],
					'max'				=>	$_[3]
			);
		}
|	WSTRING
		{
			new WideStringType($_[0],
					'value'				=>	$_[1]
			);
		}
|	WSTRING	'<'	error				'>'
		{
			$_[0]->Error("Expression expected.\n");
			$_[0]->YYErrok();
		}
;

/* 83 */	/* 3.11.4.1	Arrays */
array_declarator
:	IDENTIFIER	fixed_array_sizes
		{
			unshift(@{$_[2]},$_[1]);
			$_[2];
		}
;

fixed_array_sizes
:	fixed_array_size
		{
			[$_[1]];
		}
|	fixed_array_size	fixed_array_sizes
		{
			unshift(@{$_[2]},$_[1]);
			$_[2];
		}
;

/* 84 */
fixed_array_size
:	'['	positive_int_const	']'
		{
			$_[2];
		}
|	'['	error				']'
		{
			$_[0]->Error("Expression expected.\n");
			$_[0]->YYErrok();
		}
;

/* 85 */	/* 3.14	Attribute Declaration */
attr_dcl
:	readonly_attr_spec
										#default action
|	attr_spec
										#default action
;

/* 86 */	/* 3.12	Exception Declaration */
except_dcl
:	exception_header	'{'	'}'
		{
			$_[0]->YYData->{symbtab}->PopCurrentScope($_[1]);
			$_[1];
		}
|	exception_header	'{'	member_list	'}'
		{
			$_[0]->YYData->{symbtab}->PopCurrentScope($_[1]);
			$_[1]->Configure($_[0],
					'list_expr'			=>	$_[3]
			) if (defined $_[1]);
		}
|	exception_header	'{'	error	'}'
		{
			$_[0]->YYData->{symbtab}->PopCurrentScope($_[1]);
			$_[0]->Error("'members expected.\n");
			$_[0]->YYErrok();
		}
|	exception_header	error
		{
			$_[0]->YYData->{symbtab}->PopCurrentScope($_[1]);
			$_[0]->Error("'\x7b' expected.\n");
			$_[0]->YYErrok();
		}
;

exception_header
:	EXCEPTION	IDENTIFIER
		{
			new Exception($_[0],
					'idf'				=>	$_[2],
			);
		}
|	EXCEPTION	error
		{
			$_[0]->Error("Identifier expected.\n");
			$_[0]->YYErrok();
		}
;

/* 87 */	/* 3.13	Operation Declaration */
op_dcl
:	op_header	parameter_dcls
		{
			delete $_[0]->YYData->{unnamed_symbtab}
					if (exists $_[0]->YYData->{unnamed_symbtab});
			$_[1]->Configure($_[0],
					'list_param'	=>	$_[2]
			) if (defined $_[1]);
		}
|	op_header	parameter_dcls	raises_expr
		{
			delete $_[0]->YYData->{unnamed_symbtab}
					if (exists $_[0]->YYData->{unnamed_symbtab});
			$_[1]->Configure($_[0],
					'list_param'	=>	$_[2],
					'list_raise'	=>	$_[3]
			) if (defined $_[1]);
		}
|	op_header	parameter_dcls	raises_expr	context_expr
		{
			delete $_[0]->YYData->{unnamed_symbtab}
					if (exists $_[0]->YYData->{unnamed_symbtab});
			$_[1]->Configure($_[0],
					'list_param'	=>	$_[2],
					'list_raise'	=>	$_[3],
					'list_context'	=>	$_[4]
			) if (defined $_[1]);
		}
|	op_header	parameter_dcls				context_expr
		{
			delete $_[0]->YYData->{unnamed_symbtab}
					if (exists $_[0]->YYData->{unnamed_symbtab});
			$_[1]->Configure($_[0],
					'list_param'	=>	$_[2],
					'list_context'	=>	$_[3]
			) if (defined $_[1]);
		}
|	op_header	error
		{
			delete $_[0]->YYData->{unnamed_symbtab}
					if (exists $_[0]->YYData->{unnamed_symbtab});
			$_[0]->Error("parameters declaration expected.\n");
			$_[0]->YYErrok();
		}
;

op_header
:	op_mod	op_type_spec	IDENTIFIER
		{
			new Operation($_[0],
					'modifier'			=>	$_[1],
					'type'				=>	$_[2],
					'idf'				=>	$_[3]
			);
		}
|	op_mod	op_type_spec	error
		{
			$_[0]->Error("Identifier expected.\n");
			$_[0]->YYErrok();
		}
;

op_mod
:	op_attribute
										#default action
|	/* empty */
										#default action
;

/* 88 */	/* 3.13.1	Operation Attribute */
op_attribute
:	ONEWAY
										#default action
;

/* 89 */
op_type_spec
:	param_type_spec
										#default action
|	VOID
		{
			new VoidType($_[0],
					'value'				=>	$_[1]
			);
		}
;

/* 90 */	/* 3.13.2	Parameter Declarations */
parameter_dcls
:	'('	param_dcls	')'
		{
			$_[2];
		}
|	'('	')'
		{
			undef;
		}
|	'('	error		')'
		{
			$_[0]->Error("parameters declaration expected.\n");
			$_[0]->YYErrok();
		}
;

param_dcls
:	param_dcl
		{
			[$_[1]];
		}
|	param_dcl	','	param_dcls
		{
			unshift(@{$_[3]},$_[1]);
			$_[3];
		}
|	param_dcl	','
		{
			$_[0]->Warning("',' unexpected.\n");
			[$_[1]];
		}
|	param_dcl	';'
		{
			$_[0]->Error("';' unexpected.\n");
			[$_[1]];
		}
;

/* 91 */
param_dcl
:	param_attribute	param_type_spec	simple_declarator
		{
			new Parameter($_[0],
					'attr'				=>	$_[1],
					'type'				=>	$_[2],
					'idf'				=>	$_[3]
			);
		}
|	param_attribute	error
		{
			$_[0]->Error("Type expected.\n");
			$_[0]->YYErrok();
		}
;

/* 92 */
param_attribute
:	IN
										#default action
|	OUT
										#default action
|	INOUT
										#default action
;

/* 93 */	/* 3.13.3	Raises Expressions */
raises_expr
:	RAISES	'('	exception_names	')'
		{
			$_[3];
		}
|	RAISES	'('	error			')'
		{
			$_[0]->Error("name expected.\n");
			$_[0]->YYErrok();
		}
|	RAISES	error
		{
			$_[0]->Error("'(' expected.\n");
			$_[0]->YYErrok();
		}
;

exception_names
:	exception_name
		{
			[$_[1]];
		}
|	exception_name	','	exception_names
		{
			unshift(@{$_[3]},$_[1]);
			$_[3];
		}
;

exception_name
:	scoped_name
		{
			Exception->Lookup($_[0],$_[1]);
		}
;

/* 94 */	/* 3.13.4	Context Expressions */
context_expr
:	CONTEXT	'('	string_literals	')'
		{
			$_[3];
		}
|	CONTEXT	'('	error			')'
		{
			$_[0]->Error("string expected.\n");
			$_[0]->YYErrok();
		}
|	CONTEXT	error
		{
			$_[0]->Error("'(' expected.\n");
			$_[0]->YYErrok();
		}
;

string_literals
:	string_literal
		{
			[$_[1]];
		}
|	string_literal	','	string_literals
		{
			unshift(@{$_[3]},$_[1]);
			$_[3];
		}
;

/* 95 */
param_type_spec
:	base_type_spec
										#default action
|	string_type
										#default action
|	wide_string_type
										#default action
|	scoped_name
		{
			TypeDeclarator->Lookup($_[0],$_[1]);
		}
;

/* 96 */	/* 3.11.3.4	Fixed Type */
fixed_pt_type
:	FIXED	'<'	positive_int_const	','	positive_int_const	'>'
		{
			new FixedPtType($_[0],
					'value'				=>	$_[1],
					'd'					=>	$_[3],
					's'					=>	$_[5]
			);
		}
|	FIXED	'<'	positive_int_const	','	error				'>'
		{
			$_[0]->Error("Expression expected.\n");
			$_[0]->YYErrok();
		}
|	FIXED	'<'	error										'>'
		{
			$_[0]->Error("Expression expected.\n");
			$_[0]->YYErrok();
		}
|	FIXED	error
		{
			$_[0]->Error("'<' expected.\n");
			$_[0]->YYErrok();
		}
;

/* 97 */
fixed_pt_const_type
:	FIXED
		{
			new FixedPtConstType($_[0],
					'value'				=>	$_[1]
			);
		}
;

/* 98 */
value_base_type
:	VALUEBASE
		{
			new ValueBaseType($_[0],
					'value'				=>	$_[1]
			);
		}
;

/* 99 */	/* 3.11.2	Constructed Types */
constr_forward_decl
:	STRUCT	IDENTIFIER
		{
			new ForwardStructType($_[0],
					'idf'				=>	$_[2]
			);
		}
|	STRUCT	error
		{
			$_[0]->Error("Identifier expected.\n");
			$_[0]->YYErrok();
		}
|	UNION	IDENTIFIER
		{
			new ForwardUnionType($_[0],
					'idf'				=>	$_[2]
			);
		}
|	UNION	error
		{
			$_[0]->Error("Identifier expected.\n");
			$_[0]->YYErrok();
		}
;

/* 100 */	/* 3.6	Import Declaration */
import
:	IMPORT	imported_scope	';'
		{
			new Import($_[0],
					'value'				=>	$_[2]
			);
		}
|	IMPORT	imported_scope	error
		{
			$_[0]->Warning("';' expected.\n");
			$_[0]->YYErrok();
			new Import($_[0],
					'value'				=>	$_[2]
			);
		}
|	IMPORT	error
		{
			$_[0]->Error("Scoped name expected.\n");
			$_[0]->YYErrok();
		}
;

/* 101 */
imported_scope
:	scoped_name
										#default action
|	string_literal
										#default action
;

/* 102 */	/* 3.15.1	Repository Identity Declaration */
type_id_dcl
:	TYPEID	scoped_name	string_literal
		{
			new TypeId($_[0],
					'idf'				=>	$_[2],
					'value'				=>	$_[3]
			);
		}
|	TYPEID	scoped_name	error
		{
			$_[0]->Error("String literal expected.\n");
			$_[0]->YYErrok();
		}
|	TYPEID	error
		{
			$_[0]->Error("Scoped name expected.\n");
			$_[0]->YYErrok();
		}
;

/* 103 */	/* 3.15.2	Repository Identifier Prefic Declaration */
type_prefix_dcl
:	TYPEPREFIX	scoped_name	string_literal
		{
			new TypePrefix($_[0],
					'idf'				=>	$_[2],
					'value'				=>	$_[3]
			);
		}
|	TYPEPREFIX	scoped_name	error
		{
			$_[0]->Error("String literal expected.\n");
			$_[0]->YYErrok();
		}
|	TYPEPREFIX	'::'		string_literal
		{
			new TypePrefix($_[0],
					'idf'				=>	'',
					'value'				=>	$_[3]
			);
		}
|	TYPEPREFIX	error
		{
			$_[0]->Error("Scoped name expected.\n");
			$_[0]->YYErrok();
		}
;

/* 104 */	/* 3.14	Attribute Declaration */
readonly_attr_spec
:	READONLY	ATTRIBUTE	param_type_spec	readonly_attr_declarator
		{
			new Attributes($_[0],
					'modifier'			=>	$_[1],
					'type'				=>	$_[3],
					'list_expr'			=>	$_[4]->{list_expr},
					'list_getraise'		=>	$_[4]->{list_getraise},
			);
		}
|	READONLY	ATTRIBUTE	error
		{
			$_[0]->Error("type expected.\n");
			$_[0]->YYErrok();
		}
|	READONLY	error
		{
			$_[0]->Error("'attribute' expected.\n");
			$_[0]->YYErrok();
		}
;

/* 105 */
readonly_attr_declarator
:	simple_declarator	raises_expr
		{
			{
				'list_expr'			=> [$_[1]],
				'list_getraise'		=> $_[2]
			};
		}
|	simple_declarators
		{
			{
				'list_expr'			=> $_[1]
			};
		}
;

simple_declarators
:	simple_declarator
		{
			[$_[1]];
		}
|	simple_declarator	','	simple_declarators
		{
			unshift(@{$_[3]},$_[1]);
			$_[3];
		}
;

/* 106 */
attr_spec
:	ATTRIBUTE	param_type_spec	attr_declarator
		{
			new Attributes($_[0],
					'type'				=>	$_[2],
					'list_expr'			=>	$_[3]->{list_expr},
					'list_getraise'		=>	$_[3]->{list_getraise},
					'list_setraise'		=>	$_[3]->{list_setraise},
			);
		}
|	ATTRIBUTE	error
		{
			$_[0]->Error("type expected.\n");
			$_[0]->YYErrok();
		}
;

/* 107 */
attr_declarator
:	simple_declarator	attr_raises_expr
		{
			{
				'list_expr'			=> [$_[1]],
				'list_getraise'		=> $_[2]->{list_getraise},
				'list_setraise'		=> $_[2]->{list_setraise}
			};
		}
|	simple_declarators
		{
			{
				'list_expr'			=> $_[1]
			};
		}
;

/* 108 */
attr_raises_expr
:	get_except_expr	set_except_expr
		{
			{
				'list_getraise'		=> $_[1],
				'list_setraise'		=> $_[2]
			};
		}
|	get_except_expr
		{
			{
				'list_getraise'		=> $_[1],
			};
		}
|	set_except_expr
		{
			{
				'list_setraise'		=> $_[1]
			};
		}
;

/* 109 */
get_except_expr
:	GETRAISES	exception_list
		{
			$_[2];
		}
|	GETRAISES	error
		{
			$_[0]->Error("'(' expected.\n");
			$_[0]->YYErrok();
		}
;

/* 110 */
set_except_expr
:	SETRAISES	exception_list
		{
			$_[2];
		}
|	SETRAISES	error
		{
			$_[0]->Error("'(' expected.\n");
			$_[0]->YYErrok();
		}
;

/* 111 */
exception_list
:	'('	exception_names	')'
		{
			$_[2];
		}
|	'('	error			')'
		{
			$_[0]->Error("name expected.\n");
			$_[0]->YYErrok();
		}
;

/* 112 */	/* 3.17	Component Declaration */
component
:	component_dcl
										#default action
|	component_forward_dcl
										#default action
;

/* 113 */
component_forward_dcl
:	COMPONENT	IDENTIFIER
		{
			new ForwardComponent($_[0],
					'idf'				=>	$_[2]
			);
		}
|	COMPONENT	error
		{
			$_[0]->Error("Identifier expected.\n");
			$_[0]->YYErrok();
		}
;

/* 114 */
component_dcl
:	component_header	'{'	'}'
		{
			$_[0]->YYData->{symbtab}->PopCurrentScope($_[1]);
			$_[0]->YYData->{curr_itf} = undef;
			$_[1]->Configure($_[0],
					'list_decl'		=>	[]
			) if (defined $_[1]);
		}
|	component_header	'{'	component_body	'}'
		{
			$_[0]->YYData->{symbtab}->PopCurrentScope($_[1]);
			$_[0]->YYData->{curr_itf} = undef;
			$_[1]->Configure($_[0],
					'list_decl'		=>	$_[3]
			) if (defined $_[1]);
		}
|	component_header	'{'	error			'}'
		{
			$_[0]->YYData->{symbtab}->PopCurrentScope($_[1]);
			$_[0]->YYData->{curr_itf} = undef;
			$_[0]->Error("export declaration expected.\n");
			$_[0]->YYErrok();
		}
;

/* 115 */	/* 3.17.2	Component Header */
component_header
:	COMPONENT	IDENTIFIER	component_inheritance_spec	supported_interface_spec
		{
			new Component($_[0],
					'idf'					=>	$_[2],
					'inheritance'			=>	$_[3],
					'list_support'			=>	$_[4],
			);
		}
|	COMPONENT	IDENTIFIER	component_inheritance_spec
		{
			new Component($_[0],
					'idf'					=>	$_[2],
					'inheritance'			=>	$_[3],
			);
		}
|	COMPONENT	IDENTIFIER								supported_interface_spec
		{
			new Component($_[0],
					'idf'					=>	$_[2],
					'list_support'			=>	$_[3],
			);
		}
|	COMPONENT	IDENTIFIER
		{
			new Component($_[0],
					'idf'					=>	$_[2],
			);
		}
|	COMPONENT	error
		{
			$_[0]->Error("Identifier expected.\n");
			$_[0]->YYErrok();
		}
;

/* 116 */
supported_interface_spec
:	SUPPORTS	interface_names
		{
			$_[2];
		}
|	SUPPORTS	error
		{
			$_[0]->Error("Interface name expected.\n");
			$_[0]->YYErrok();
		}
;

/* 117 */
component_inheritance_spec
:	':'	scoped_name
		{
			Component->Lookup($_[0],$_[2]);
		}
|	':'	error
		{
			$_[0]->Error("Scoped name expected.\n");
			$_[0]->YYErrok();
		}
;

/* 118 */	/* 3.17.3	Component Body */
component_body
:	component_exports
										#default action
;

component_exports
:	component_export
		{
			[$_[1]->getRef()];
		}
|	component_export component_exports
		{
			unshift(@{$_[2]},$_[1]->getRef());
			$_[2];
		}
;

/* 119 */
component_export
:	provides_dcl	';'
										#default action
|	uses_dcl		';'
										#default action
|	emits_dcl		';'
										#default action
|	publishes_dcl	';'
										#default action
|	consumes_dcl	';'
										#default action
|	attr_dcl		';'
										#default action
|	provides_dcl	error
		{
			$_[0]->Warning("';' expected.\n");
			$_[0]->YYErrok();
			$_[1];						#default action
		}
|	uses_dcl		error
		{
			$_[0]->Warning("';' expected.\n");
			$_[0]->YYErrok();
			$_[1];						#default action
		}
|	emits_dcl		error
		{
			$_[0]->Warning("';' expected.\n");
			$_[0]->YYErrok();
			$_[1];						#default action
		}
|	publishes_dcl	error
		{
			$_[0]->Warning("';' expected.\n");
			$_[0]->YYErrok();
			$_[1];						#default action
		}
|	consumes_dcl	error
		{
			$_[0]->Warning("';' expected.\n");
			$_[0]->YYErrok();
			$_[1];						#default action
		}
|	attr_dcl		error
		{
			$_[0]->Warning("';' expected.\n");
			$_[0]->YYErrok();
			$_[1];						#default action
		}
;

/* 120 */	/* 3.17.3.1	Facets and Navigation */
provides_dcl
:	PROVIDES	interface_type	IDENTIFIER
		{
			new Provides($_[0],
					'idf'					=>	$_[3],
					'type'					=>	$_[2],
			);
		}
|	PROVIDES	interface_type	error
		{
			$_[0]->Error("Identifier expected.\n");
			$_[0]->YYErrok();
		}
|	PROVIDES	error
		{
			$_[0]->Error("Interface type expected.\n");
			$_[0]->YYErrok();
		}
;

/* 121 */
interface_type
:	scoped_name
		{
			BaseInterface->Lookup($_[0],$_[1]);
		}
|	OBJECT
										#default action
;

/* 122 */	/* 3.17.3.2	Receptacles */
uses_dcl
:	USES	uses_mod	interface_type	IDENTIFIER
		{
			new Uses($_[0],
					'modifier'				=>	$_[2],
					'idf'					=>	$_[4],
					'type'					=>	$_[3],
			);
		}
|	USES	uses_mod	interface_type	error
		{
			$_[0]->Error("Identifier expected.\n");
			$_[0]->YYErrok();
		}
|	USES	uses_mod	error
		{
			$_[0]->Error("Interface type expected.\n");
			$_[0]->YYErrok();
		}
;

uses_mod
:	MULTIPLE
										#default action
|	/* empty */
										#default action
;

/* 123 */	/* 3.17.4.2	Emitters */
emits_dcl
:	EMITS	scoped_name	IDENTIFIER
		{
			new Emits($_[0],
					'idf'					=>	$_[3],
					'type'					=>	Event->Lookup($_[0],$_[2]),
			);
		}
|	EMITS	scoped_name	error
		{
			$_[0]->Error("Identifier expected.\n");
			$_[0]->YYErrok();
		}
|	EMITS	error
		{
			$_[0]->Error("Scoped name expected.\n");
			$_[0]->YYErrok();
		}
;

/* 124 */	/* 3.17.4.1	Publishers */
publishes_dcl
:	PUBLISHES	scoped_name	IDENTIFIER
		{
			new Publishes($_[0],
					'idf'					=>	$_[3],
					'type'					=>	Event->Lookup($_[0],$_[2]),
			);
		}
|	PUBLISHES	scoped_name	error
		{
			$_[0]->Error("Identifier expected.\n");
			$_[0]->YYErrok();
		}
|	PUBLISHES	error
		{
			$_[0]->Error("Scoped name expected.\n");
			$_[0]->YYErrok();
		}
;

/* 125 */	/* 3.17.5	Event Sinks */
consumes_dcl
:	CONSUMES	scoped_name	IDENTIFIER
		{
			new Consumes($_[0],
					'idf'					=>	$_[3],
					'type'					=>	Event->Lookup($_[0],$_[2]),
			);
		}
|	CONSUMES	scoped_name	error
		{
			$_[0]->Error("Identifier expected.\n");
			$_[0]->YYErrok();
		}
|	CONSUMES	error
		{
			$_[0]->Error("Scoped name expected.\n");
			$_[0]->YYErrok();
		}
;

/* 126 */	/* 3.18	Home Declaration */
home_dcl
:	home_header	home_body
		{
			$_[0]->YYData->{symbtab}->PopCurrentScope($_[1]);
			$_[0]->YYData->{curr_itf} = undef;
			$_[1]->Configure($_[0],
					'list_decl'			=>	$_[2],
			) if (defined $_[1]);
		}
;

/* 127 */	/* 3.18.2	Home Header */
home_header
:	home_header_spec	MANAGES	scoped_name	primary_key_spec
		{
			$_[1]->Configure($_[0],
					'manage'			=>	Component->Lookup($_[0],$_[3]),
					'primarykey'		=>	$_[4],
			) if (defined $_[1]);
		}
|	home_header_spec	MANAGES	scoped_name
		{
			$_[1]->Configure($_[0],
					'manage'			=>	Component->Lookup($_[0],$_[3]),
			) if (defined $_[1]);
		}
|	home_header_spec	MANAGES	error
		{
			$_[0]->Error("Scoped name expected.\n");
			$_[0]->YYErrok();
			$_[1];						#default action
		}
;

home_header_spec
:	HOME	IDENTIFIER	home_inheritance_spec	supported_interface_spec
		{
			new Home($_[0],
					'idf'				=>	$_[2],
					'inheritance'		=>	$_[3],
					'list_support'		=>	$_[4],
			);
		}
|	HOME	IDENTIFIER	home_inheritance_spec
		{
			new Home($_[0],
					'idf'				=>	$_[2],
					'inheritance'		=>	$_[3],
			);
		}
|	HOME	IDENTIFIER							supported_interface_spec
		{
			new Home($_[0],
					'idf'				=>	$_[2],
					'list_support'		=>	$_[3],
			);
		}
|	HOME	IDENTIFIER
		{
			new Home($_[0],
					'idf'				=>	$_[2],
			);
		}
|	HOME	error
		{
			$_[0]->Error("Identifier expected.\n");
			$_[0]->YYErrok();
		}
;

/* 128 */
home_inheritance_spec
:	':'	scoped_name
		{
			Home->Lookup($_[0],$_[2]);
		}
|	':'	error
		{
			$_[0]->Error("Scoped name expected.\n");
			$_[0]->YYErrok();
		}
;

/* 129 */
primary_key_spec
:	PRIMARYKEY	scoped_name
		{
			Value->Lookup($_[0],$_[2]);
		}
|	PRIMARYKEY	error
		{
			$_[0]->Error("Scoped name expected.\n");
			$_[0]->YYErrok();
		}
;

/* 130 */	/* 3.18.3	Home Body */
home_body
:	'{'	'}'
		{
			[];
		}
|	'{'	home_exports	'}'
		{
			$_[2];
		}
|	'{'	error			'}'
		{
			$_[0]->Error("export declaration expected.\n");
			$_[0]->YYErrok();
		}
;

home_exports
:	home_export
		{
			[$_[1]->getRef()];
		}
|	home_export	home_exports
		{
			unshift(@{$_[2]},$_[1]->getRef());
			$_[2];
		}
;

/* 131 */
home_export
:	export
										#default action
|	factory_dcl	';'
										#default action
|	finder_dcl	';'
										#default action
|	factory_dcl	error
		{
			$_[0]->Warning("';' expected.\n");
			$_[0]->YYErrok();
			$_[1];						#default action
		}
|	finder_dcl	error
		{
			$_[0]->Warning("';' expected.\n");
			$_[0]->YYErrok();
			$_[1];						#default action
		}
;

/* 132 */
factory_dcl
:	factory_header_param	raises_expr
		{
			$_[1]->Configure($_[0],
					'list_raise'	=>	$_[2]
			) if (defined $_[1]);
		}
|	factory_header_param
										#default action
;

factory_header_param
:	factory_header	'('	')'
		{
			delete $_[0]->YYData->{unnamed_symbtab}
					if (exists $_[0]->YYData->{unnamed_symbtab});
			$_[1];						#default action
		}
|	factory_header	'('	init_param_decls	')'
		{
			delete $_[0]->YYData->{unnamed_symbtab}
					if (exists $_[0]->YYData->{unnamed_symbtab});
			$_[1]->Configure($_[0],
					'list_param'		=>	$_[2]
			) if (defined $_[1]);
		}
|	factory_header	'('	error				')'
		{
			delete $_[0]->YYData->{unnamed_symbtab}
					if (exists $_[0]->YYData->{unnamed_symbtab});
			$_[0]->Error("init_param_decls expected.\n");
			$_[0]->YYErrok();
		}
|	factory_header	error
		{
			delete $_[0]->YYData->{unnamed_symbtab}
					if (exists $_[0]->YYData->{unnamed_symbtab});
			$_[0]->Error("'(' expected.\n");
			$_[0]->YYErrok();
		}
;

factory_header
:	FACTORY	IDENTIFIER
		{
			new Factory($_[0],							# like Operation
					'idf'				=>	$_[2],
			);
		}
|	FACTORY	error
		{
			$_[0]->Error("Identifier expected.\n");
			$_[0]->YYErrok();
		}
;

/* 133 */
finder_dcl
:	finder_header_param	raises_expr
		{
			$_[1]->Configure($_[0],
					'list_raise'	=>	$_[2]
			) if (defined $_[1]);
		}
|	finder_header_param
										#default action
;

finder_header_param
:	finder_header	'('	')'
		{
			delete $_[0]->YYData->{unnamed_symbtab}
					if (exists $_[0]->YYData->{unnamed_symbtab});
			$_[1];						#default action
		}
|	finder_header	'('	init_param_decls	')'
		{
			delete $_[0]->YYData->{unnamed_symbtab}
					if (exists $_[0]->YYData->{unnamed_symbtab});
			$_[1]->Configure($_[0],
					'list_param'		=>	$_[2]
			) if (defined $_[1]);
		}
|	finder_header	'('	error				')'
		{
			delete $_[0]->YYData->{unnamed_symbtab}
					if (exists $_[0]->YYData->{unnamed_symbtab});
			$_[0]->Error("init_param_decls expected.\n");
			$_[0]->YYErrok();
		}
|	finder_header	error
		{
			delete $_[0]->YYData->{unnamed_symbtab}
					if (exists $_[0]->YYData->{unnamed_symbtab});
			$_[0]->Error("'(' expected.\n");
			$_[0]->YYErrok();
		}
;

finder_header
:	FINDER	IDENTIFIER
		{
			new Finder($_[0],							# like Operation
					'idf'				=>	$_[2],
			);
		}
|	FINDER	error
		{
			$_[0]->Error("Identifier expected.\n");
			$_[0]->YYErrok();
		}
;

/* 134 */	/* 3.16	Event Declaration */
event
:	event_dcl
										#default action
|	event_abs_dcl
										#default action
|	event_forward_dcl
										#default action
;

/* 135 */	/* 3.16.3	Event Forward Declaration */
event_forward_dcl
:				EVENTTYPE	IDENTIFIER
		{
			new ForwardRegularEvent($_[0],
					'idf'				=>	$_[2]
			);
		}
|	ABSTRACT	EVENTTYPE	IDENTIFIER
		{
			new ForwardAbstractEvent($_[0],
					'idf'				=>	$_[3]
			);
		}
;

/* 136 */	/* 3.16.2	Abstract Event Type */
event_abs_dcl
:	event_abs_header	'{'	'}'
		{
			$_[0]->YYData->{symbtab}->PopCurrentScope($_[1]);
			$_[0]->YYData->{curr_itf} = undef;
			$_[1]->Configure($_[0],
					'list_decl'		=>	[]
			) if (defined $_[1]);
		}
|	event_abs_header	'{'	exports	'}'
		{
			$_[0]->YYData->{symbtab}->PopCurrentScope($_[1]);
			$_[0]->YYData->{curr_itf} = undef;
			$_[1]->Configure($_[0],
					'list_decl'		=>	$_[3]
			) if (defined $_[1]);
		}
|	event_abs_header	'{'	error	'}'
		{
			$_[0]->YYData->{symbtab}->PopCurrentScope($_[1]);
			$_[0]->YYData->{curr_itf} = undef;
			$_[0]->Error("export expected.\n");
			$_[0]->YYErrok();
		}
;

event_abs_header
:	ABSTRACT	EVENTTYPE	IDENTIFIER
		{
			new AbstractEvent($_[0],
					'idf'				=>	$_[3],
			);
		}
|	ABSTRACT	EVENTTYPE	IDENTIFIER	value_inheritance_spec
		{
			new AbstractEvent($_[0],
					'idf'				=>	$_[3],
					'inheritance'		=>	$_[4]
			);
		}
|	ABSTRACT	EVENTTYPE	error
		{
			$_[0]->Error("Identifier expected.\n");
			$_[0]->YYErrok();
		}
;

/* 137 */	/* 3.16.1	Regular Event Type */
event_dcl
:	event_header	'{'	'}'
		{
			$_[0]->YYData->{symbtab}->PopCurrentScope($_[1]);
			$_[0]->YYData->{curr_itf} = undef;
			$_[1]->Configure($_[0],
					'list_decl'		=>	[]
			) if (defined $_[1]);
		}
|	event_header	'{'	value_elements	'}'
		{
			$_[0]->YYData->{symbtab}->PopCurrentScope($_[1]);
			$_[0]->YYData->{curr_itf} = undef;
			$_[1]->Configure($_[0],
					'list_decl'		=>	$_[3]
			) if (defined $_[1]);
		}
|	event_header	'{'	error			'}'
		{
			$_[0]->YYData->{symbtab}->PopCurrentScope($_[1]);
			$_[0]->YYData->{curr_itf} = undef;
			$_[0]->Error("value_element expected.\n");
			$_[0]->YYErrok();
		}
;

/* 138 */
event_header
:				EVENTTYPE	IDENTIFIER
		{
			new RegularEvent($_[0],
					'idf'				=>	$_[2],
			);
		}
|	CUSTOM		EVENTTYPE	IDENTIFIER
		{
			new RegularEvent($_[0],
					'modifier'			=>	$_[1],
					'idf'				=>	$_[3],
			);
		}
|				EVENTTYPE	IDENTIFIER	value_inheritance_spec
		{
			new RegularEvent($_[0],
					'idf'				=>	$_[2],
					'inheritance'		=>	$_[3]
			);
		}
|	CUSTOM		EVENTTYPE	IDENTIFIER	value_inheritance_spec
		{
			new RegularEvent($_[0],
					'modifier'			=>	$_[1],
					'idf'				=>	$_[3],
					'inheritance'		=>	$_[4]
			);
		}
|				EVENTTYPE	error
		{
			$_[0]->Error("Identifier expected.\n");
			$_[0]->YYErrok();
		}
|	CUSTOM		EVENTTYPE	error
		{
			$_[0]->Error("Identifier expected.\n");
			$_[0]->YYErrok();
		}
;

%%

package Parser;

use strict;
use vars qw($IDL_version);
$IDL_version = '3.0';

use CORBA::IDL::symbtab;
use CORBA::IDL::node;

require CORBA::IDL::lexer;

sub BuildUnop
{
	my($op,$expr) = @_;

	my $node = new UnaryOp($_[0],	'op'	=>	$op);
	push(@$expr,$node);
	return $expr;
}

sub BuildBinop
{
	my($left,$op,$right) = @_;

	my $node = new BinaryOp($_[0],	'op'	=>	$op);
	push(@$left,@$right);
	push(@$left,$node);
	return $left;
}

